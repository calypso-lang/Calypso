pub data Option[T] =
    | Some(T)
    | None

impl[T] Option[T] with
    pub fn unwrap(self): Self ->
        match self with
        | None -> panic("Called `Option.unwrap()` on a `None` value"),
        | Some(value) -> value
        end
        
    pub fn unwrap_or(self, default: T): Self ->
        match self, default with
        | None, default -> default,
        | Some(value), _ -> value
        end
    
    pub fn unwrap_or_else(self, default: fn(): T): Self ->
        match self, default with
        | None, default -> default(),
        | Some(value), _ -> value
        end

    pub fn map[U](self, f: fn(T): U): Option[U] ->
        match self, f with
        | None, _ -> None,
        | Some(value), f -> Some(f(value))
        end
end

// some function outside that does some stuff with generic options
// (in the real stdlib, this function would probably be implemented on option)

pub fn option_or[T](a: Option[T], b: Option[T]): Option[T] ->
    match a, b with
    | Some(v), _    -> Some(v),
    | None, Some(v) -> Some(v),
    | _             -> None
    end

pub fn factorial(n: uint): uint ->
    match n with
    | 0 -> 1
    | n -> n * factorial(n - 1)
    end

pub fn factorial_tail(n: uint, acc: uint \\ 1): uint ->
    match n, acc with
    | 0, acc -> acc
    | n, acc -> factorial_tail(n - 1, n * acc)
    end

pub fn factorial_iter(n: uint): uint ->
    1.to(n).product()

pub fn factorial_iter_loop(n: uint): uint -> do
    let mut res = 1
    if n == 0 then return 1

    for 1 in 1..n do
        res *= i
    end

   res
end