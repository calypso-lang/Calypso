#![allow(clippy::all)]
#![allow(warnings)]
use calypso_diagnostic::prelude::*;
use calypso_ast::expr::{Expr, Primary, BinOpKind, UnOpKind, Radix, Suffix, Numeral};
use calypso_ast::stmt::{Stmt};
use calypso_base::symbol::{kw::Keyword, Symbol};
use calypso_base::span::Spanned;

use crate::lexer::{Token, IdentLike};

grammar<'input>(source_id: usize);

extern {
    type Location = u32;
    type Error = CalError;

    enum Token {
        "NumberLit" => Token::Numeral(<Numeral>),

        "+"  => Token::Plus,
        "-"  => Token::Minus,
        "*"  => Token::Star,
        "/"  => Token::Slash,
        "%"  => Token::Percent,
        "**" => Token::StarStar,

        "&&" => Token::AndAnd,
        "||" => Token::PipePipe,
        "!"  => Token::Bang,

        "&"  => Token::And,
        "^"  => Token::Caret,
        "|"  => Token::Pipe,
        ">>" => Token::GtGt,
        "<<" => Token::LtLt,

        "(" => Token::LParen,
        ")" => Token::RParen,

        "==" => Token::EqEq,
        "!=" => Token::BangEq,
        "<"  => Token::Lt,
        ">"  => Token::Gt,
        "<=" => Token::LtEq,
        ">=" => Token::GtEq,

        "=" => Token::Eq,

        "Ident" => Token::IdentLike(IdentLike::Ident(<Symbol>)),

        "true"  => Token::IdentLike(IdentLike::Keyword(Keyword::True)),
        "false" => Token::IdentLike(IdentLike::Keyword(Keyword::False)),
        "let"   => Token::IdentLike(IdentLike::Keyword(Keyword::Let)),
    }
}

// Left-associative operator
//
// # Arguments
//
// Op: Operator(s) at this level
// Next: Next level of precedence
//
BinOp<Op, Next>: Expr = {
    // Parse an expression at the next level of precedence (or higher)
    Next,
    // Parse an expression at this level of precedence (or lower)
    <lhsl:@L> <lhs:BinOp<Op, Next>> <lhsr:@R>
        <opl:@L> <op:Op> <opr:@R> <rhsl:@L>
        <rhs:Next> <rhsr:@R> => Expr::BinOp(
            (lhsl, Box::new(lhs), lhsr).into(),
            (opl, op, opr).into(),
            (rhsl, Box::new(rhs), rhsr).into())
}

// Right-associative operator
//
// # Arguments
//
// Op: Operator(s) at this level
// Next: Next level of precedence
//
BinOpR<Op, Next>: Expr = {
    // Parse an expression at the next level of precedence (or higher)
    Next,
    // Parse an expression at this level of precedence (or lower)
    <lhsl:@L> <lhs:Next> <lhsr:@R>
        <opl:@L> <op:Op> <opr:@R>
        <rhsl:@L> <rhs:BinOpR<Op, Next>> <rhsr:@R> => Expr::BinOp(
            (lhsl, Box::new(lhs), lhsr).into(),
            (opl, op, opr).into(),
            (rhsl, Box::new(rhs), rhsr).into())
}

// === Statements === //

pub Stmts: Vec<Spanned<Stmt>> = {
    <mut v:(<@L> <Stmt> <@R>)*> => v.into_iter().map(|x| x.into()).collect()
}

pub Stmt: Stmt = LetStmt;

// `let <sym> = <expr>`
LetStmt: Stmt = {
    "let" <syml:@L> <sym:"Ident"> <symr:@R> "="
        <exprl:@L> <expr:Expr> <exprr:@R> => Stmt::Let(
            (syml, sym, symr).into(),
            (exprl, expr, exprr).into())
}

// === Expressions === //

// Lowest level of precedence
pub Expr: Expr = LogOrExpr;

// infixl (||)
LogOrExpr = BinOp<LogOrOp, LogAndExpr>;
// infixl (&&)
LogAndExpr = BinOp<LogAndOp, BitOrExpr>;

// infixl (|)
BitOrExpr = BinOp<BitOrOp, BitXorExpr>;
// infixl (^)
BitXorExpr = BinOp<BitXorOp, BitAndExpr>;
// infixl (&)
BitAndExpr = BinOp<BitAndOp, EqualityExpr>;

// infixl (== | !=)
EqualityExpr = BinOp<EqualityOp, ComparisonExpr>;
// infixl (< | <= | > | >=)
ComparisonExpr = BinOp<ComparisonOp, BitShiftExpr>;

// infixl (<< | >>)
BitShiftExpr = BinOp<BitShiftOp, AddExpr>;

// infixl (+ | -)
AddExpr = BinOp<AddOp, MulExpr>;
// infixl (* | / | %)
MulExpr = BinOp<MulOp, PowExpr>;
// infixr (**)
PowExpr = BinOpR<PowOp, UnaryExpr>;

// unary expressions
UnaryExpr = {
    Term,
    <opl:@L> "-" <opr:@R> <exprl:@L> <expr:UnaryExpr> <exprr:@R> => Expr::UnOp(
        (opl, UnOpKind::Negative, opr).into(),
        (exprl, Box::new(expr), exprr).into()),
    <opl:@L> "!" <opr:@R> <exprl:@L> <expr:UnaryExpr> <exprr:@R> => Expr::UnOp(
        (opl, UnOpKind::UnaryNot, opr).into(),
        (exprl, Box::new(expr), exprr).into())
}

// terms (primary and grouping)
Term: Expr = {
    Primary,
    "(" <Expr> ")"
}

Primary: Expr = {
    <l:@L> <lit:"NumberLit"> <r:@R> => Expr::Primary((l, Primary::Number(lit), r).into()),
    Bool,
}

Bool: Expr = {
    <l:@L> "true" <r:@R> => Expr::Primary((l, Primary::Bool(true), r).into()),
    <l:@L> "false" <r:@R> => Expr::Primary((l, Primary::Bool(false), r).into())
}

LogOrOp: BinOpKind = {
    "||" => BinOpKind::LogicalOr
}

LogAndOp: BinOpKind = {
    "&&" => BinOpKind::LogicalAnd
}

AddOp: BinOpKind = {
    "+" => BinOpKind::Add,
    "-" => BinOpKind::Subtract
}

MulOp: BinOpKind = {
    "*" => BinOpKind::Multiply,
    "/" => BinOpKind::Divide,
    "%" => BinOpKind::Modulo
}

PowOp: BinOpKind = {
    "**" => BinOpKind::Exponent
}

BitOrOp: BinOpKind = {
    "|" => BinOpKind::BitOr
}

BitXorOp: BinOpKind = {
    "^" => BinOpKind::BitXor
}

BitAndOp: BinOpKind = {
    "&" => BinOpKind::BitAnd
}

BitShiftOp: BinOpKind = {
    ">>" => BinOpKind::BitShiftRight,
    "<<" => BinOpKind::BitShiftLeft
}

EqualityOp: BinOpKind = {
    "==" => BinOpKind::Equal,
    "!=" => BinOpKind::NotEqual
}

ComparisonOp: BinOpKind = {
    "<" => BinOpKind::Lt,
    ">" => BinOpKind::Gt,
    "<=" => BinOpKind::LtEq,
    ">=" => BinOpKind::GtEq,
}