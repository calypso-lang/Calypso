#![allow(clippy::all)]
#![allow(warnings)]
use calypso_diagnostic::prelude::*;
use calypso_ast::expr::{Expr, Primary, BinOpKind, UnOpKind, Radix, Suffix, Numeral};
use calypso_base::symbol::{kw::Keyword, Symbol};

use crate::lexer::{Token, IdentLike};

grammar<'input>(source_id: usize);

extern {
    type Location = usize;
    type Error = CalError;

    enum Token {
        "NumberLit" => Token::Numeral(<Numeral>),

        "+"  => Token::Plus,
        "-"  => Token::Minus,
        "*"  => Token::Star,
        "/"  => Token::Slash,
        "%"  => Token::Percent,
        "**" => Token::StarStar,

        "&&" => Token::AndAnd,
        "||" => Token::PipePipe,
        "!"  => Token::Bang,

        "&"  => Token::And,
        "^"  => Token::Caret,
        "|"  => Token::Pipe,
        ">>" => Token::GtGt,
        "<<" => Token::LtLt,

        "(" => Token::LParen,
        ")" => Token::RParen,

        "==" => Token::EqEq,
        "!=" => Token::BangEq,
        "<"  => Token::Lt,
        ">"  => Token::Gt,
        "<=" => Token::LtEq,
        ">=" => Token::GtEq,

        "Ident" => Token::IdentLike(IdentLike::Ident(<Symbol>)),

        "true"  => Token::IdentLike(IdentLike::Keyword(Keyword::True)),
        "false" => Token::IdentLike(IdentLike::Keyword(Keyword::False)),
    }
}

// Left-associative operator
//
// # Arguments
//
// Op: Operator(s) at this level
// Next: Next level of precedence
//
BinOp<Op, Next>: Box<Expr> = {
    // Parse an expression at the next level of precedence (or higher)
    Next,
    // Parse an expression at this level of precedence (or lower)
    BinOp<Op, Next> Op Next => Box::new(Expr::BinOp(<>))
}

// Right-associative operator
//
// # Arguments
//
// Op: Operator(s) at this level
// Next: Next level of precedence
//
BinOpR<Op, Next>: Box<Expr> = {
    // Parse an expression at the next level of precedence (or higher)
    Next,
    // Parse an expression at this level of precedence (or lower)
    Next Op BinOpR<Op, Next> => Box::new(Expr::BinOp(<>))
}

pub Expr: Box<Expr> = LogOrExpr;

// infixl (||) : 1
LogOrExpr = BinOp<LogOrOp, LogAndExpr>;
// infixl (&&) : 2
LogAndExpr = BinOp<LogAndOp, BitOrExpr>;

// infixl (|) : 3
BitOrExpr = BinOp<BitOrOp, BitXorExpr>;
// infixl (^) : 4
BitXorExpr = BinOp<BitXorOp, BitAndExpr>;
// infixl (&) : 5
BitAndExpr = BinOp<BitAndOp, EqualityExpr>;

// infixl (== | !=) : 6
EqualityExpr = BinOp<EqualityOp, ComparisonExpr>;
// infixl (< | <= | > | >=) : 7
ComparisonExpr = BinOp<ComparisonOp, BitShiftExpr>;

// infixl (<< | >>) : 8
BitShiftExpr = BinOp<BitShiftOp, AddExpr>;

// infixl (+ | -) : 9
AddExpr = BinOp<AddOp, MulExpr>;
// infixl (* | / | %) : 10
MulExpr = BinOp<MulOp, PowExpr>;
// infixr (**): 11
PowExpr = BinOpR<PowOp, UnaryExpr>;

// unary expressions: 12
UnaryExpr = {
    Term,
    <lo:@L> "-" <hi:@R> <op:UnaryExpr> => Box::new(Expr::UnOp((lo, UnOpKind::Negative, hi).into(), op)),
    <lo:@L> "!" <hi:@R> <op:UnaryExpr> => Box::new(Expr::UnOp((lo, UnOpKind::UnaryNot, hi).into(), op))
}

// terms (primary and grouping): 13
Term: Box<Expr> = {
    Primary,
    "(" <Expr> ")"
}

Primary: Box<Expr> = {
    "NumberLit" => Box::new(Expr::Primary(Primary::Number(<>))),
    Bool,
}

Bool: Box<Expr> = {
    "true" => Box::new(Expr::Primary(Primary::Bool(true))),
    "false" => Box::new(Expr::Primary(Primary::Bool(false)))
}

LogOrOp: BinOpKind = {
    "||" => BinOpKind::LogicalOr
}

LogAndOp: BinOpKind = {
    "&&" => BinOpKind::LogicalAnd
}

AddOp: BinOpKind = {
    "+" => BinOpKind::Add,
    "-" => BinOpKind::Subtract
}

MulOp: BinOpKind = {
    "*" => BinOpKind::Multiply,
    "/" => BinOpKind::Divide,
    "%" => BinOpKind::Modulo
}

PowOp: BinOpKind = {
    "**" => BinOpKind::Exponent
}

BitOrOp: BinOpKind = {
    "|" => BinOpKind::BitOr
}

BitXorOp: BinOpKind = {
    "^" => BinOpKind::BitXor
}

BitAndOp: BinOpKind = {
    "&" => BinOpKind::BitAnd
}

BitShiftOp: BinOpKind = {
    ">>" => BinOpKind::BitShiftRight,
    "<<" => BinOpKind::BitShiftLeft
}

EqualityOp: BinOpKind = {
    "==" => BinOpKind::Equal,
    "!=" => BinOpKind::NotEqual
}

ComparisonOp: BinOpKind = {
    "<" => BinOpKind::Lt,
    ">" => BinOpKind::Gt,
    "<=" => BinOpKind::LtEq,
    ">=" => BinOpKind::GtEq,
}